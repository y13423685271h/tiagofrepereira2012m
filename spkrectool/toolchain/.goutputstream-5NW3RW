#!/usr/bin/env python
# vim: set fileencoding=utf-8 :
# Manuel Guenther <Manuel.Guenther@idiap.ch>

import os
from .. import utils
import bob

class FileSelectorZT:
  """This class provides shortcuts for selecting different files for different stages of the verification process"""
  
  def __init__(self, config, db):
    """Initialize the file selector object with the current configuration"""
    self.m_config = config
    self.m_db_options = db 
    self.m_db = db.db
    
  def __options__(self, name):
    """Returnes the options specified by the database, if available"""
    if hasattr(self.m_db_options, name):
      return eval('self.m_db_options.'+name)
    else:
      return {}
  
  def sort(self, files):
    """Returns a sorted version of the given list of File's (or other structures that define an 'id' data member).
    The files will be sorted according to their id, and duplicate entries will be removed."""
    sorted_files = sorted(files, cmp=lambda x,y: cmp(x.id, y.id))
    return [f for i,f in enumerate(sorted_files) if not i or sorted_files[i-1].id != f.id]  
    
    
  ### Original images and preprocessing
  def original_image_list(self):
    """Returns the list of original images that can be used for image preprocessing"""
    #return self.m_db.files(directory=self.m_config.img_input_dir, extension=self.m_config.img_input_ext, protocol=self.m_config.protocol, **self.__options__('all_files_options'))
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, **self.__options__('all_files_options')))
    known = set()
    directory=self.m_config.img_input_dir
    extension=self.m_config.img_input_ext
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]
    
  def annotation_list(self):
    """Returns the list of annotation files, if any (else None)"""
    if not hasattr(self.m_config, 'pos_input_dir') or self.m_config.pos_input_dir == None:
      return None

    #return self.m_db.files(directory=self.m_config.pos_input_dir, extension=self.m_config.pos_input_ext, protocol=self.m_config.protocol, **self.__options__('all_files_options'))
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, **self.__options__('all_files_options')))
    known = set()
    directory=self.m_config.pos_input_dir
    extension=self.m_config.pos_input_ext
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]
    
    
  def preprocessed_image_list(self):
    """Returns the list of preprocessed images and assures that the normalized image path is existing"""
    utils.ensure_dir(self.m_config.preprocessed_dir)
    #return self.m_db.files(directory=self.m_config.preprocessed_dir, extension=self.m_config.default_extension, protocol=self.m_config.protocol, **self.__options__('all_files_options'))
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, **self.__options__('all_files_options')))
    known = set()
    directory=self.m_config.preprocessed_dir
    extension=self.m_config.default_extension
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]
    

  def feature_list(self):
    """Returns the list of features and assures that the feature path is existing"""
    utils.ensure_dir(self.m_config.features_dir)
    #return self.m_db.files(directory=self.m_config.features_dir, extension=self.m_config.default_extension, protocol=self.m_config.protocol, **self.__options__('all_files_options'))
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, **self.__options__('all_files_options')))
    known = set()
    directory=self.m_config.features_dir
    extension=self.m_config.default_extension
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]

  ### Training and projecting features
  def training_image_list(self):
    """Returns the list of images that should be used for extractor training"""
    #return self.m_db.files(directory=self.m_config.preprocessed_dir, extension=self.m_config.default_extension, protocol=self.m_config.protocol, groups='world', **self.__options__('world_extractor_options'))  
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, groups='world', **self.__options__('world_extractor_options')))
    known = set()
    directory=self.m_config.preprocessed_dir
    extension=self.m_config.default_extension
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]
    

  def training_feature_list(self):
    """Returns the list of features that should be used for projector training"""
    #return self.m_db.files(directory=self.m_config.features_dir, extension=self.m_config.default_extension, protocol=self.m_config.protocol, groups='world', **self.__options__('world_projector_options'))  
    files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, groups='world', **self.__options__('world_projector_options')))
    known = set()
    directory=self.m_config.features_dir
    extension=self.m_config.default_extension
    return [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]

  def training_feature_list_by_clients(self, dir_type, step):
    """Returns the list of training features, which is split up by the client ids."""
    # get the type of directory that is required
    if dir_type == 'preprocessed': 
      cur_dir = self.m_config.preprocessed_dir 
    elif dir_type == 'features': 
      cur_dir = self.m_config.features_dir 
    elif dir_type == 'projected_ubm': 
      cur_dir = self.m_config.projected_ubm_dir
    elif dir_type == 'projected_isv': 
      cur_dir = self.m_config.projected_isv_dir

    # if requested, define the subset of training data to be used for this step
    if step == 'train_extractor':
      cur_world_options = self.__options__('world_extractor_options')
    elif step == 'train_projector':
      cur_world_options = self.__options__('world_projector_options')
    elif step == 'train_enroler':
      cur_world_options = self.__options__('world_enroler_options')

    # iterate over all training clients
    features_by_clients_options = {}
    if 'subworld' in cur_world_options: features_by_clients_options['subworld'] = cur_world_options['subworld']
    features_by_clients_options.update(self.__options__('features_by_clients_options'))
    train_clients = self.m_db.clients(groups='world', protocol=self.m_config.protocol, **features_by_clients_options)
    training_filenames = {}
    
    for m in train_clients:
      # collect training features for current client id
      #train_data_m = self.m_db.files(directory=cur_dir, extension=self.m_config.default_extension, protocol=self.m_config.protocol, groups='world', model_ids=(m,), **cur_world_options) 
      files = self.sort(self.m_db.objects(protocol=self.m_config.protocol, groups='world', model_ids=(m.id,), **cur_world_options))
      known = set()
      directory=cur_dir
      extension=self.m_config.default_extension
      train_data_m = [file.make_path(directory, extension) for file in files if file.path not in known and not known.add(file.path)]

      # add this model to the list
      training_filenames[m] = train_data_m
    # return the list of features which is grouped by client id
    return training_filenames
    

  def extractor_file(self):
    """Returns the file where to save the trainined extractor model to"""
    utils.ensure_dir(os.path.dirname(self.m_config.extractor_file))
    return self.m_config.extractor_file

  def projector_file(self):
    """Returns the file where to save the trained model"""
    utils.ensure_dir(os.path.dirname(self.m_config.projector_file))
    return self.m_config.projector_file
    
  def projected_ubm_list(self):
    """Returns the list of projected features and assures that the projected feature path is existing"""
    utils.ensure_dir(self.m_config.projected_ubm_dir)
    #return self.m_db.files(directory=self.m_config.project